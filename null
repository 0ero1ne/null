#!/usr/local/bin/bash
# packet manager
# 
# packet manager for scripts and software made in bash

# Version
# Current: 0.2-a5-rev3

# TODO for 0.2-a5-rev4
# - organize functions for each arguments
#	.MUST clean the code and create functions for each arguments, needed to 
#	.avoid "spaghetti" code
# - clean the help output

# TODO
# - install function
#	.I have to choose between hosting a private server to have all the scripts in
#	.a remote folder or it gets tricky
# - delete function
#	.See above
# - update function (needs improvement)
#	.Currently the only way I can update the packet manage is via git
# - search function (has to work both online and locally)
#	.To GET the list of files from a github an API must be used and there is daily
#	.limit unless a client_id is used. I might have to host it in a private server.
# EOT

#################################################################################
# Variables																		
server=https://raw.githubusercontent.com/0ero1ne/null/master/					# server address
current_version=0.2-a5-rev3														# current version
local_path=$(dirname "$0")

# Visual output
printf "\n${Red}%14s\n" "^"
# Version
printf "${Yellow}%12s${NC} [${Blue}%s${NC}]\n\n" ".null" "$current_version"
#printf "\t${NC}[${Blue}%s${NC}]\n\n" 

#################################################################################
# argument parser
case $1 in
	# List of all installed scripts
	"-l")	
		# Iterate all the file in the bin folder
		for f in $local_path/bin/*; do
			app=$(basename $f)
			info=$(sed -n 2p $f)
			# Output
			printf "${Green}%12s ${Yellow}%s\n" "$app" "$info"
		done
	;;

	# Search function (local only)
	"-s")
		# Checks for keyword
		if [ "$2" ]; then
			# Local function
			# Search all the entries and store it in a variable
			local_result=$(null -l | grep -i "$2")
			
			# DEBUG
			# Need improvements
			# online=$(null -l | grep -i "$2")
			#for x in $server_files; do
				#printf "$(curl -s https://raw.githubusercontent.com/0ero1ne/null/master/bin/$x | sed -n "2p")\n"
				##printf "$($x | sed -n "2p")"
				##printf "$x\n"
			#done

			# If result is not empty print it
			if [ -n "$local_result" ]; then
				printf "${NC}Installed scripts:\n"
				printf "$local_result\n\n"
			else
				# Error message
				printf "${Red}\tNo results found!\n\n"
			fi
			
		else
			# Error message for empty argument
			printf "${Red}%28s\n\n" "Give me a key to search!"
		fi
	;;

	# Retrieve info from a script (local only for now)
	"-i")
		if [ "$2" ]; then
			# Iterate apps
			# DEPRECATE; WILL USE FIND INSTEAD?
			for f in $(dirname "$0")/bin/*; do
				# If the argument match the name of the app
				# Pars information
	    		if [[ "$(basename $f)" == "$2" ]]; then	    	
	    			# HEAD
	    			printf "${NC}Name: ${Green}$(basename $f)$NC\n"
	    			# Version
	    			printf "${NC}Version:${Green}$(cat $f | sed -n '3p' | cut -d '#' -f 2)\n"
	    			# Description
	    			printf "${NC}Description:${Green}$(cat $f | sed -n '4p' | cut -d '#' -f 2)\n"
	    			# if TODO exist print the list
	    			if [[ $(cat $f | sed -n '/# TODO/,/# EOT/p') ]];then
	    				printf "${NC}TODO:${Green}\n$(cat $f | sed -n '/# TODO/,/# EOT/p' | sed '1d;$d' | cut -f 2 -d '#')\n"
	    			fi
	    			# App found, exit 0
	    			echo	
	    			exit 0
    			fi
			done
			# Loop end, return error message
			printf "${Red}\tApp not found!\n\n"
		else
			# Error message for empty argument
			printf "${Red}%25s\n\n" "Give me an app name!"
		fi
	;;

	# Update function (works only for null)
	"-u")
		printf "${NC}Checking for updates..."
		last_version=$(curl -s $server/null | grep current_version= | head -n 1 | cut -f 2 -d '=')
		if [ $current_version == $last_version ]; then
			printf "\n${Green}Up-to-date.\n\n"
		else
			printf "\n\nA new version has been found!\n"
			printf "\n${Red}Current version: ${NC}$current_version"
			printf "\n${Green}  Newer version: ${NC}$last_version\n\n"
		fi
	;;

	# If no arguments print help
	*)
		printf "${NC}"
		printf """\t-l to list 
\t-s to search 
\t-i to info
\t-u to update
\n"""
	;;
esac

echo
# EOF
